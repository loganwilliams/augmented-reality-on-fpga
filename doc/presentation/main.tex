% $Header: /cvsroot/latex-beamer/latex-beamer/solutions/generic-talks/generic-ornate-15min-45min.en.tex,v 1.5 2007/01/28 20:48:23 tantau Exp $
\documentclass{beamer}

\mode<presentation>
{
  \usetheme{Madrid}

  \setbeamercovered{invisible}
}

\usepackage[english]{babel}

\usepackage[latin1]{inputenc}

\usepackage{times}
\usepackage[T1]{fontenc}
\usepackage{graphicx}

\title[Augmented Reality on FPGA]{Augmented Reality on FPGA}
\subtitle{Realtime Object Recognition and Image Processing}
\author{Logan P. Williams \and Jos\'{e} E. Cruz Serrall\'{e}s}
\date{15 November 2011}

%\AtBeginSubsection[]
%{
%	\begin{frame}<beamer>{Outline}
%		\tableofcontents[currentsection,currentsubsection]
%	\end{frame}
%}

%\beamerdefaultoverlayspecification{<+->}
\begin{document}

\begin{frame}
	\titlepage
\end{frame}

\section{Introduction}
% Logan
\begin{frame}
	\frametitle{Introduction}
	\begin{itemize}
		\item Overlay a digital image on a physical object in realtime.
		\item In this case, we want to identify a picture frame in captured video, and output video with another image distorted to fit on top of the picture frame.
	\end{itemize}
\end{frame}

% Logan
\begin{frame}
% example output image
	\frametitle{Example Image}
	\begin{figure}
		\centering
		\includegraphics[width=0.9\textwidth]{example1.png}
	\end{figure}
\end{frame}

\begin{frame}
% example output image
	\frametitle{Example Image}
	\begin{figure}
		\centering
		\includegraphics[width=0.9\textwidth]{example2.jpg}
	\end{figure}
\end{frame}

\begin{frame}
% example output image
	\frametitle{Example Image}
	\begin{figure}
		\centering
		\includegraphics[width=0.9\textwidth]{example3.jpg}
	\end{figure}
\end{frame}

%Logan
\section{Top-Level Overview}
\begin{frame}
% big block diagram slide
	\frametitle{Top-Level Overview}
	\begin{figure}
		\centering
		\includegraphics[width=\textwidth]{../proposal/simplified_block_diagram.png}
	\end{figure}
\end{frame}

\section{Individual Module Specifications}
% Logan
\subsection{projective\_transform}
\begin{frame}
	\frametitle{{\tt projective\_transform}: Purpose}
	\begin{figure}
		\centering
		\includegraphics[width=\textwidth]{../proposal/arbiskew_graphic.png}
	\end{figure}
	\begin{itemize}
		\item Skew to any arbitrary convex quadrilateral
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{{\tt projective\_transform}: How the algorithm works}
	\begin{figure}
		\centering
		\includegraphics[width=0.7\textwidth]{../proposal/arbiskew_graphic.png}
	\end{figure}
	\begin{enumerate}
		\item[1] Calculate the distance of line $\overline{A\prime D\prime}$ and assign it to $d_{ad}$.
		\item[2] Do the same for $\overline{B\prime C\prime}$ and assign it to $d_{bc}$.
		\item[3] Create two ``iterator points,'' point $I_A$ and $I_B$ initially located at $A\prime$ and $B\prime$.
		\item[4] Let $o_x = 0$ and $o_y = 0$
		\item[5] Calculate the distance between the iterator points, assign it to $d_i$.
		\item[6] Create a third iterator point, $I_C$ at the location $I_A$.
	\end{enumerate}
\end{frame}

\begin{frame}
	\frametitle{{\tt projective\_transform}: How the algorithm works}
	\begin{figure}
		\centering
		\includegraphics[width=0.7\textwidth]{../proposal/arbiskew_graphic.png}
	\end{figure}
	\begin{enumerate}
		\item[7] Assign the pixel value of $I_C$ to pixel $(o_x, o_y)$ in the original image.
		\item[8] Move $I_C$ along line $\overline{I_A I_B}$ by an amount $= \frac{d_i}{width_{original}}$.
		\item[9] Increment $o_x$.
		\item[10] Repeat steps 7--9 until $I_C = I_B$.
	\end{enumerate}
\end{frame}

\begin{frame}
	\frametitle{{\tt projective\_transform}: How the algorithm works}
	\begin{figure}
		\centering
		\includegraphics[width=0.7\textwidth]{../proposal/arbiskew_graphic.png}
	\end{figure}
	\begin{enumerate}
	\item[11] Move $I_A$ along line $\overline{A\prime D\prime}$ by an amount $= \frac{d_{ad}}{height_{original}}$.
	\item[12] Move $I_B$ along line $\overline{B\prime C\prime}$ by an amount $= \frac{d_{bc}}{height_{original}}$.
	\item[13] Increment $o_y$.
	\item[14] Repeat steps 5--13 until $I_A = D\prime$ and $I_B = C\prime$.
	\end{enumerate}
\end{frame}

\begin{frame}
	\frametitle{{\tt projective\_transform}: Example}
	\begin{figure}
		\centering
		\includegraphics[width=0.8\textwidth]{../../sketches/arbiskew/IMG_5046.jpg}
		\caption{The original image}
	\end{figure}
\end{frame}

\begin{frame}
	\frametitle{{\tt projective\_transform}: Example}
	\begin{figure}
		\centering
		\includegraphics[width=0.8\textwidth]{skew_rectangle.png}
		\caption{We want it skewed to this quadrilateral}
	\end{figure}
\end{frame}

\begin{frame}
	\frametitle{{\tt projective\_transform}: Example}
	\begin{figure}
		\centering
		\includegraphics[width=0.8\textwidth]{projected_halfway_line.jpg}
		\caption{Halfway along line $A\prime B\prime$}
	\end{figure}
\end{frame}

\begin{frame}
	\frametitle{{\tt projective\_transform}: Example}
	\begin{figure}
		\centering
		\includegraphics[width=0.8\textwidth]{projected_halfway.jpg}
		\caption{Halfway through skewing the image}
	\end{figure}
\end{frame}

\begin{frame}
	\frametitle{{\tt projective\_transform}: Example}
	\begin{figure}
		\centering
		\includegraphics[width=0.8\textwidth]{projected_final.jpg}
		\caption{The final image (processed with MATLAB)}
	\end{figure}
\end{frame}

\begin{frame}
	\frametitle{{\tt projective\_transform}: FPGA implementation}
	\begin{itemize}
	\item Straightfoward implementation of the above algorithm
	\item Uses coregen Divider modules for the divisions
	\item Requires only 2*640*480 + 4*480 multiplications per clock cycle
	\item Uses an iterative algorithm for finding distances (pipelined at the end of each line of the image)
	\item Processes pixels ``on-the-fly'' from {\tt LPF}
	\item Negligible memory requirements (a handful of registers)
	\end{itemize}
\end{frame}


\begin{frame}
	\frametitle{{\tt projective\_transform}: How it Interfaces}
	\begin{figure}
		\centering
		\includegraphics[width=\textwidth]{../proposal/block_diagram_with_wires.png}
	\end{figure}
\end{frame}

% Logan
\subsection{object\_recognition}


\begin{frame}
	\frametitle{{\tt object\_recognition}}

	\begin{figure}
		\centering
		\includegraphics[width=0.8\textwidth]{../proposal/simplified_block_diagram.png}
	\end{figure}
	
	\begin{itemize}
		\item Mark corners of frame with four differently colored dots.
		\item Recognition begins in the {\tt ntsc\_capture} module, which detects these colors as it is capturing data and sends the pixel info to the {\tt object\_recognition} module.
		
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{{\tt object\_recognition}}

	\begin{itemize}
		\item Take linear weighted center of mass for each image
		\item Sums the (x,y) coordinates for each color as it receives them. (8 running sums, 2 for each color)
		\item When the frame is done, divide each sum by the number of summed items
		\item The resulting 4 (x,y) pairs are the corners of the frame
		\item By looking for pixels in {\tt ntsc\_capture} we significantly reduce the amount of time spent in {\tt object\_recognition}
	\end{itemize}
\end{frame}

% Jose
\subsection{LPF}
\begin{frame}
	\frametitle{{\tt LPF}: its purpose}
	\begin{columns}[c]
		\column{.5\textwidth}
		\begin{itemize}
		\item<1-> {\tt projective\_transform} \(\rightarrow\) aliasing
		\item<3-> Aliasing reduces the quality of an image
		\item<4-> Lowpass filtering prevents aliasing
		\item<5-> Information of an image is mostly phase
		\item<8-> Symmetric Type I FIR filter \(\rightarrow\) 0 phase distortion
		\item<9-> Parks-McClellan: reasonable accuracy, symmetric, easily calculable
		\item<10-> FIR PM filter reduces mem. acceses to 1.5/pixel
		\end{itemize}
	
		\column{.5\textwidth}
		\only<1>{graphic showing normal signal}
		\only<2>{graphic aliases}
		\only<3>{zoom in on aliased pixels}
		\only<4>{picture depicting lowpass filter in 2D}
		\only<5>{picture of original picture}
		\only<6>{picture of other image}
		\only<7-8>{picture of original phase with other's magnitude}
		\only<9>{frequency response of Parks-McClellan filter}
	\end{columns}
\end{frame}
\begin{frame}
	\frametitle{{\tt LPF}: the algorithm}
	\begin{columns}[c]
		\column{.5\textwidth}
		\begin{enumerate}
		\item<1-> Given an arbitrary image \& skewing coefficients \( M_x \) \& \( M_y \).
		\item<2-> Fetch a filter with cutoff \( \frac{\pi}{M_y} \).
		\item<3-> Filter each column and store in memory.
		\item<4-> Fetch a filter with cutoff \( \frac{\pi}{M_x} \).
		\item<5-> Filter each row and output to {\tt projective\_transform}.
		\item<6-> Repeat this process every refresh cycle.
		\end{enumerate}

		\column{.5\textwidth}
		\only<1>
		{
			graphic showing the interface between object\_recognition and LPF \\
			image \\
			magnitude fourier plot of image \\
		}
		\only<2>
		{
			magnitude plot of image \\
			magnitude plot of filter with cutoff pi/2 \\
		}
		\only<3>
		{
			magnitude plot of image \\
			magnitude plot of filter with cutoff pi/2 \\
			magnitude fourier plot of filtered \\
		}
		\only<4>
		{
			magnitude plot of filtered image \\
			magnitude plot of filter with curoff pi/4 \\
		}
		\only<5>
		{
			magnitude plot of filtered image \\
			mangitude plot of filter with cutoff pi/5 \\
			magnitude plot of output \\
		}
		\only<6>
		{
			magnitude plot of original \\
			magnitude plot of filter \\
			magnitude plot of output \\
		}
	\end{columns}
\end{frame}

% Jose
\subsection{memory\_interface}
\begin{frame}
	\frametitle{{\tt memory\_interface}}
	\begin{columns}[t]
		\column{.6\textwidth}
		\begin{itemize}
		\item<1-> 1 image is a lot of data: \( 640\cdot480\cdot24 \text{ bits} \approx 0.88 \text{MiB} \)
		\item<2-> Total BRAM on board: \( 0.316 \text{MiB} \)
		\item<3-> We need to store 4 images in memory!
		\item<4-> Let's use the ZBT RAM: \( 2\cdot2.25 \text{MiB} \)
		\item<5-> Not so fast: 1 clock cycle per memory access
		\item<6-> 1 pixel per address would require a clock speed \( > 100MHz \)
		\item<7-> Let's store store 18 bits per pixel or 2 per address
		\end{itemize}

		\column{.4\textwidth}
	\end{columns}
\end{frame}

\begin{frame}
	\frametitle{{\tt memory\_interface}: operation}
	\begin{enumerate}
		\item
	\end{enumerate}
\end{frame}	

% Jose
\subsection{system io}
\begin{frame}
	\frametitle{system io: {\tt ntsc\_capture}}
\end{frame}

\begin{frame}
	\frametitle{system io: vga\_write}
\end{frame}

% Jose
\subsection{timeline}
\begin{frame}
	\frametitle{timeline}
\end{frame}

\end{document}
